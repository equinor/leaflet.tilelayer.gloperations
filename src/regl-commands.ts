import REGL from 'regl';

import vertDouble from './shaders/double.vs';
import vertSingle from './shaders/single.vs';
import vertMulti3 from './shaders/multi3.vs';
import vertMulti4 from './shaders/multi4.vs';
import vertMulti5 from './shaders/multi5.vs';
import vertMulti6 from './shaders/multi6.vs';
import vertSingleNotTransformed from './shaders/singleNotTransformed.vs';

import fragInterpolateColor from './shaders/interpolateColor.fs';
import fragInterpolateColorOnly from './shaders/interpolateColorOnly.fs';
import fragInterpolateValue from './shaders/interpolateValue.fs';
import fragSingle from './shaders/single.fs';
import fragHsPregen from './shaders/hillshading/hsPregen.fs';
import fragMulti1Calc from './shaders/multiAnalyze1Calc.fs';
import fragMulti2Calc from './shaders/multiAnalyze2Calc.fs';
import fragMulti3Calc from './shaders/multiAnalyze3Calc.fs';
import fragMulti4Calc from './shaders/multiAnalyze4Calc.fs';
import fragMulti5Calc from './shaders/multiAnalyze5Calc.fs';
import fragMulti6Calc from './shaders/multiAnalyze6Calc.fs';
import fragDiffCalc from './shaders/diffCalc.fs';
import fragConvertDem from './shaders/convertDem.fs';
import fragDrawResult from './shaders/drawResult.fs';
import fragConvolutionSmooth from './shaders/convolutionSmooth.fs';
import fragHsAdvMergeAndScaleTiles from './shaders/hillshading/hsAdvMergeAndScaleTiles.fs';
import fragHsAdvNormals from './shaders/hillshading/hsAdvNormals.fs';
import fragHsAdvDirectLight from './shaders/hillshading/hsAdvDirect.fs';
import fragHsAdvSoftShadows from './shaders/hillshading/hsAdvSoftShadows.fs';
import fragHsAdvAmbientShadows from './shaders/hillshading/hsAdvAmbientShadows.fs';
import fragHsAdvFinalColorscale from './shaders/hillshading/hsAdvFinalColorscale.fs';
import fragHsAdvFinalBaselayer from './shaders/hillshading/hsAdvFinalBaselayer.fs';

import {
  Dictionary,
  DrawCommon,
  DrawTile,
  DrawTileHsSimple,
  DrawTileHsPregen,
  DrawTileInterpolateColor,
  DrawTileInterpolateColorOnly,
  DrawTileInterpolateValue,
  CalcTileMultiAnalyze1,
  CalcTileMultiAnalyze2,
  CalcTileMultiAnalyze3,
  CalcTileMultiAnalyze4,
  CalcTileMultiAnalyze5,
  CalcTileMultiAnalyze6,
  DrawTileResult,
  CalcTileDiff,
  ConvertDem,
  ConvolutionSmooth,
  HsAdvMergeAndScaleTiles,
  HsAdvCalcNormals,
  HsAdvDirectLightning,
  HsAdvSoftShadows,
  HsAdvAmbientShadows,
  HsAdvFinalColorscale,
  HsAdvFinalBaselayer,
} from './types';

import {
  DEG2RAD,
  SLOPEFACTOR,
} from './constants';

import * as util from './util';

const littleEndian = util.machineIsLittleEndian();

/**
 * The object generated by this function should be merged into the DrawConfig for each Regl
 * command in the application.
 */
export function getCommonDrawConfiguration(
  tileSize: number,
  nodataValue: number,
): REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props> {
  return {
    uniforms: {
      nodataValue,
      littleEndian,
      transformMatrix: ({ viewportWidth, viewportHeight }) => (
        util.getTransformMatrix(viewportWidth, viewportHeight)
      ),
    },
    attributes: {
      position: (_, { canvasCoordinates }) => {
        const [left, top] = canvasCoordinates;
        const [right, bottom] = [left + tileSize, top + tileSize];
        return [
          [left,  top   ],
          [right, top   ],
          [left,  bottom],
          [right, bottom],
        ];
      },
    },
    // We don't need the depth buffer for 2D drawing. Leaving it enabled (and failing to clear it
    // between draw calls) results in visual artifacts.
    depth: { enable: false },
    primitive: 'triangle strip',
    count: 4,
    viewport: (_, { canvasSize: [width, height] }) => ({ width, height }),
  };
}

/**
 * The resulting Regl DrawCommand is used to draw a single tile. The fragment shader decodes the
 * Float32 value of a pixel and colorizes it with the given color scale (and/or sentinel values).
 */
export function createDrawTileCommand(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
  fragMacros: Dictionary<any>,
) {
  return regl<DrawTile.Uniforms, DrawTile.Attributes, DrawTile.Props>({
    ...commonConfig,
    vert: vertSingle,
    frag: util.defineMacros(fragSingle, fragMacros),
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      scaleLength: regl.prop<DrawTile.Props, 'scaleLength'>('scaleLength'),
      sentinelLength: regl.prop<DrawTile.Props, 'sentinelLength'>('sentinelLength'),
      scaleColormap: regl.prop<DrawTile.Props, 'scaleColormap'>('scaleColormap'),
      sentinelColormap: regl.prop<DrawTile.Props, 'sentinelColormap'>('sentinelColormap'),
      texture: (_, { texture }) => texture,
      enableSimpleHillshade: (_, { enableSimpleHillshade }) => enableSimpleHillshade,
      offset: 0,
      azimuth: 0,
      altitude: 0,
      slopescale: 0,
      deg2rad: DEG2RAD,
      slopeFactor: SLOPEFACTOR,
      tileSize: 0,
      textureSize: 0,
      textureBounds: [0, 0, 0, 0],
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoord: (_, { textureBounds }) => util.getTexCoordVerticesTriangleStripQuad(textureBounds),
    },
  });
}

/**
 * The resulting Regl DrawCommand is used to draw a single tile. The fragment shader decodes the
 * Float32 value of a pixel and colorizes it with the given color scale (and/or sentinel values).
 * Hillshading is applied with a simple and fast algorithm
 */
export function createDrawTileHsSimpleCommand(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
  fragMacros: Dictionary<any>,
) {
  return regl<DrawTileHsSimple.Uniforms, DrawTileHsSimple.Attributes, DrawTileHsSimple.Props>({
    ...commonConfig,
    vert: vertSingle,
    frag: util.defineMacros(fragSingle, fragMacros),
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      scaleLength: regl.prop<DrawTileHsSimple.Props, 'scaleLength'>('scaleLength'),
      sentinelLength: regl.prop<DrawTileHsSimple.Props, 'sentinelLength'>('sentinelLength'),
      scaleColormap: regl.prop<DrawTileHsSimple.Props, 'scaleColormap'>('scaleColormap'),
      sentinelColormap: regl.prop<DrawTileHsSimple.Props, 'sentinelColormap'>('sentinelColormap'),
      texture: (_, { texture }) => texture,
      enableSimpleHillshade: (_, { enableSimpleHillshade }) => enableSimpleHillshade,
      azimuth: (_, { azimuth }) => azimuth,
      altitude: (_, { altitude }) => altitude,
      slopescale: (_, { slopescale }) => slopescale,
      deg2rad: DEG2RAD,
      slopeFactor: SLOPEFACTOR,
      offset: (_, { offset }) => offset,
      textureBounds: (_, { textureBounds }) => {
        return [
          [textureBounds[0].x],
          [textureBounds[0].y],
          [textureBounds[1].x],
          [textureBounds[1].y]
        ];
      },
      textureSize: (_, { textureSize }) => textureSize,
      tileSize: (_, { tileSize }) => tileSize,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoord: (_, { textureBounds }) => util.getTexCoordVerticesTriangleStripQuad(textureBounds),
    },
  });
}

/**
 * The resulting Regl DrawCommand is used to draw a single tile. The fragment shader decodes the
 * Float32 value of a pixel and colorizes it with the given color scale (and/or sentinel values).
 * Hillshading is applied from a pre-generated texture
 */
export function createDrawTileHsPregenCommand(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
  fragMacros: Dictionary<any>,
) {
  return regl<DrawTileHsPregen.Uniforms, DrawTileHsPregen.Attributes, DrawTileHsPregen.Props>({
    ...commonConfig,
    vert: vertDouble,
    frag: util.defineMacros(fragHsPregen, fragMacros),
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      scaleLength: regl.prop<DrawTileHsPregen.Props, 'scaleLength'>('scaleLength'),
      sentinelLength: regl.prop<DrawTileHsPregen.Props, 'sentinelLength'>('sentinelLength'),
      scaleColormap: regl.prop<DrawTileHsPregen.Props, 'scaleColormap'>('scaleColormap'),
      sentinelColormap: regl.prop<DrawTileHsPregen.Props, 'sentinelColormap'>('sentinelColormap'),
      texture: (_, { texture }) => texture,
      hillshadePregenTexture: (_, { hillshadePregenTexture }) => hillshadePregenTexture,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoordA: (_, { textureBounds }) => util.getTexCoordVerticesTriangleStripQuad(textureBounds),
      texCoordB: (_, { textureBoundsHs }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsHs),
    },
  });
}

export function createCalcTileMultiAnalyze1Command(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<
    CalcTileMultiAnalyze1.Uniforms,
    CalcTileMultiAnalyze1.Attributes,
    CalcTileMultiAnalyze1.Props
  >({
    ...commonConfig,
    vert: vertSingle,
    frag: fragMulti1Calc,
    depth: {
      enable: false
    },
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      filterLowA: (_, { filterLowA }) => filterLowA,
      filterHighA: (_, { filterHighA }) => filterHighA,
      multiplierA: (_, { multiplierA }) => multiplierA,
      textureA: (_, { textureA }) => textureA,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoord: (_, { textureBoundsA }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsA),
    },
    framebuffer: regl.prop<CalcTileMultiAnalyze1.Props, 'fbo'>("fbo"),
  });
}

export function createCalcTileMultiAnalyze2Command(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<
    CalcTileMultiAnalyze2.Uniforms,
    CalcTileMultiAnalyze2.Attributes,
    CalcTileMultiAnalyze2.Props
  >({
    ...commonConfig,
    vert: vertDouble,
    frag: fragMulti2Calc,
    depth:  {
      enable: false
    },
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      filterLowA: (_, { filterLowA }) => filterLowA,
      filterHighA: (_, { filterHighA }) => filterHighA,
      filterLowB: (_, { filterLowB }) => filterLowB,
      filterHighB: (_, { filterHighB }) => filterHighB,
      multiplierA: (_, { multiplierA }) => multiplierA,
      multiplierB: (_, { multiplierB }) => multiplierB,
      textureA: (_, { textureA }) => textureA,
      textureB: (_, { textureB }) => textureB,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoordA: (_, { textureBoundsA }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsA),
      texCoordB: (_, { textureBoundsB }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsB),
    },
    framebuffer: regl.prop<CalcTileMultiAnalyze2.Props, 'fbo'>("fbo"),
  });
}

export function createCalcTileMultiAnalyze3Command(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<
    CalcTileMultiAnalyze3.Uniforms,
    CalcTileMultiAnalyze3.Attributes,
    CalcTileMultiAnalyze3.Props
  >({
    ...commonConfig,
    vert: vertMulti3,
    frag: fragMulti3Calc,
    depth:  {
      enable: false
    },
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      filterLowA: (_, { filterLowA }) => filterLowA,
      filterHighA: (_, { filterHighA }) => filterHighA,
      filterLowB: (_, { filterLowB }) => filterLowB,
      filterHighB: (_, { filterHighB }) => filterHighB,
      filterLowC: (_, { filterLowC }) => filterLowC,
      filterHighC: (_, { filterHighC }) => filterHighC,
      multiplierA: (_, { multiplierA }) => multiplierA,
      multiplierB: (_, { multiplierB }) => multiplierB,
      multiplierC: (_, { multiplierC }) => multiplierC,
      textureA: (_, { textureA }) => textureA,
      textureB: (_, { textureB }) => textureB,
      textureC: (_, { textureC }) => textureC,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoordA: (_, { textureBoundsA }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsA),
      texCoordB: (_, { textureBoundsB }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsB),
      texCoordC: (_, { textureBoundsC }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsC),
    },
    framebuffer: regl.prop<CalcTileMultiAnalyze3.Props, 'fbo'>("fbo"),
  });
}

export function createCalcTileMultiAnalyze4Command(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<
    CalcTileMultiAnalyze4.Uniforms,
    CalcTileMultiAnalyze4.Attributes,
    CalcTileMultiAnalyze4.Props
  >({
    ...commonConfig,
    vert: vertMulti4,
    frag: fragMulti4Calc,
    depth: {
      enable: false
    },
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      filterLowA: (_, { filterLowA }) => filterLowA,
      filterHighA: (_, { filterHighA }) => filterHighA,
      filterLowB: (_, { filterLowB }) => filterLowB,
      filterHighB: (_, { filterHighB }) => filterHighB,
      filterLowC: (_, { filterLowC }) => filterLowC,
      filterHighC: (_, { filterHighC }) => filterHighC,
      filterLowD: (_, { filterLowD }) => filterLowD,
      filterHighD: (_, { filterHighD }) => filterHighD,
      multiplierA: (_, { multiplierA }) => multiplierA,
      multiplierB: (_, { multiplierB }) => multiplierB,
      multiplierC: (_, { multiplierC }) => multiplierC,
      multiplierD: (_, { multiplierD }) => multiplierD,
      textureA: (_, { textureA }) => textureA,
      textureB: (_, { textureB }) => textureB,
      textureC: (_, { textureC }) => textureC,
      textureD: (_, { textureD }) => textureD,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoordA: (_, { textureBoundsA }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsA),
      texCoordB: (_, { textureBoundsB }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsB),
      texCoordC: (_, { textureBoundsC }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsC),
      texCoordD: (_, { textureBoundsD }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsD),
    },
    framebuffer: regl.prop<CalcTileMultiAnalyze1.Props, 'fbo'>("fbo"),
  });
}

export function createCalcTileMultiAnalyze5Command(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<
    CalcTileMultiAnalyze5.Uniforms,
    CalcTileMultiAnalyze5.Attributes,
    CalcTileMultiAnalyze5.Props
  >({
    ...commonConfig,
    vert: vertMulti5,
    frag: fragMulti5Calc,
    depth: {
      enable: false
    },
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      filterLowA: (_, { filterLowA }) => filterLowA,
      filterHighA: (_, { filterHighA }) => filterHighA,
      filterLowB: (_, { filterLowB }) => filterLowB,
      filterHighB: (_, { filterHighB }) => filterHighB,
      filterLowC: (_, { filterLowC }) => filterLowC,
      filterHighC: (_, { filterHighC }) => filterHighC,
      filterLowD: (_, { filterLowD }) => filterLowD,
      filterHighD: (_, { filterHighD }) => filterHighD,
      filterLowE: (_, { filterLowE }) => filterLowE,
      filterHighE: (_, { filterHighE }) => filterHighE,
      multiplierA: (_, { multiplierA }) => multiplierA,
      multiplierB: (_, { multiplierB }) => multiplierB,
      multiplierC: (_, { multiplierC }) => multiplierC,
      multiplierD: (_, { multiplierD }) => multiplierD,
      multiplierE: (_, { multiplierE }) => multiplierE,
      textureA: (_, { textureA }) => textureA,
      textureB: (_, { textureB }) => textureB,
      textureC: (_, { textureC }) => textureC,
      textureD: (_, { textureD }) => textureD,
      textureE: (_, { textureE }) => textureE,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoordA: (_, { textureBoundsA }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsA),
      texCoordB: (_, { textureBoundsB }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsB),
      texCoordC: (_, { textureBoundsC }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsC),
      texCoordD: (_, { textureBoundsD }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsD),
      texCoordE: (_, { textureBoundsE }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsE),
    },
    framebuffer: regl.prop<CalcTileMultiAnalyze5.Props, 'fbo'>("fbo"),
  });
}

export function createCalcTileMultiAnalyze6Command(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<
    CalcTileMultiAnalyze6.Uniforms,
    CalcTileMultiAnalyze6.Attributes,
    CalcTileMultiAnalyze6.Props
  >({
    ...commonConfig,
    vert: vertMulti6,
    frag: fragMulti6Calc,
    depth:  {
      enable: false
    },
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      filterLowA: (_, { filterLowA }) => filterLowA,
      filterHighA: (_, { filterHighA }) => filterHighA,
      filterLowB: (_, { filterLowB }) => filterLowB,
      filterHighB: (_, { filterHighB }) => filterHighB,
      filterLowC: (_, { filterLowC }) => filterLowC,
      filterHighC: (_, { filterHighC }) => filterHighC,
      filterLowD: (_, { filterLowD }) => filterLowD,
      filterHighD: (_, { filterHighD }) => filterHighD,
      filterLowE: (_, { filterLowE }) => filterLowE,
      filterHighE: (_, { filterHighE }) => filterHighE,
      filterLowF: (_, { filterLowF }) => filterLowF,
      filterHighF: (_, { filterHighF }) => filterHighF,
      multiplierA: (_, { multiplierA }) => multiplierA,
      multiplierB: (_, { multiplierB }) => multiplierB,
      multiplierC: (_, { multiplierC }) => multiplierC,
      multiplierD: (_, { multiplierD }) => multiplierD,
      multiplierE: (_, { multiplierE }) => multiplierE,
      multiplierF: (_, { multiplierF }) => multiplierF,
      textureA: (_, { textureA }) => textureA,
      textureB: (_, { textureB }) => textureB,
      textureC: (_, { textureC }) => textureC,
      textureD: (_, { textureD }) => textureD,
      textureE: (_, { textureE }) => textureE,
      textureF: (_, { textureF }) => textureF,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoordA: (_, { textureBoundsA }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsA),
      texCoordB: (_, { textureBoundsB }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsB),
      texCoordC: (_, { textureBoundsC }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsC),
      texCoordD: (_, { textureBoundsD }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsD),
      texCoordE: (_, { textureBoundsE }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsE),
      texCoordF: (_, { textureBoundsF }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsF)
    },
    framebuffer: regl.prop<CalcTileMultiAnalyze6.Props, 'fbo'>("fbo"),
  });
}

export function createCalcTileDiffCommand(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<
    CalcTileDiff.Uniforms,
    CalcTileDiff.Attributes,
    CalcTileDiff.Props
  >({
    ...commonConfig,
    vert: vertDouble,
    frag: fragDiffCalc,
    depth:  {
      enable: false
    },
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      textureA: (_, { textureA }) => textureA,
      textureB: (_, { textureB }) => textureB,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoordA: (_, { textureBoundsA }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsA),
      texCoordB: (_, { textureBoundsB }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsB),
    },
    framebuffer: regl.prop<CalcTileDiff.Props, 'fbo'>("fbo"),
  });
}

export function createDrawResultCommand(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
  fragMacros: Dictionary<any>,
) {
  return regl<
    DrawTileResult.Uniforms,
    DrawTileResult.Attributes,
    DrawTileResult.Props
  >({
    ...commonConfig,
    vert: vertSingle,
    frag: util.defineMacros(fragDrawResult, fragMacros),
    depth:  {
      enable: false
    },
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      scaleLength: regl.prop<DrawTileResult.Props, 'scaleLength'>('scaleLength'),
      sentinelLength: regl.prop<DrawTileResult.Props, 'sentinelLength'>('sentinelLength'),
      scaleColormap: regl.prop<DrawTileResult.Props, 'scaleColormap'>('scaleColormap'),
      sentinelColormap: regl.prop<DrawTileResult.Props, 'sentinelColormap'>('sentinelColormap'),
      texture: regl.prop<DrawTileResult.Props, 'texture'>("texture"),
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoord: [[0, 1], [1, 1], [0, 0], [1, 0]],
    },
  });
}

/**
 * The command output by this function converts a tile in DEM format
 * to float32 packed as rgba.
 */
export function createConvertDemCommand(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<
    ConvertDem.Uniforms,
    ConvertDem.Attributes,
    ConvertDem.Props
  >({
    ...commonConfig,
    vert: vertSingle,
    frag: fragConvertDem,
    depth:  {
      enable: false
    },
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      texture: (_, { texture }) => texture,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoord: [[0, 1], [1, 1], [0, 0], [1, 0]],
    },
    framebuffer: regl.prop<ConvertDem.Props, 'fbo'>("fbo"),
  });
}

/**
 * The DrawCommand output by this function interpolates, for each pixel, between two values, one
 * from `textureA` and one from `textureB`. The same color scale / sentinel values are applied to
 * both.
 */
export function createDrawTileInterpolateValueCommand(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
  fragMacros: Dictionary<any>,
) {
  return regl<
    DrawTileInterpolateValue.Uniforms,
    DrawTileInterpolateValue.Attributes,
    DrawTileInterpolateValue.Props
  >({
    ...commonConfig,
    vert: vertDouble,
    frag: util.defineMacros(fragInterpolateValue, fragMacros),
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      scaleLength: regl.prop<DrawTileInterpolateValue.Props, 'scaleLength'>('scaleLength'),
      sentinelLength: regl.prop<DrawTileInterpolateValue.Props, 'sentinelLength'>('sentinelLength'),
      scaleColormap: regl.prop<DrawTileInterpolateValue.Props, 'scaleColormap'>('scaleColormap'),
      sentinelColormap: regl.prop<DrawTileInterpolateValue.Props, 'sentinelColormap'>('sentinelColormap'),
      textureA: (_, { textureA }) => textureA,
      textureB: (_, { textureB }) => textureB,
      interpolationFraction: (_, { interpolationFraction }) => interpolationFraction,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoordA: (_, { textureBoundsA }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsA),
      texCoordB: (_, { textureBoundsB }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsB),
    },
  });
}

/**
 * The behavior of this DrawCommand is similar to the one above, except that pixels from `textureA`
 * are colorized with one color scale / set of sentinel values, while pixels from `textureB` use a
 * different color scale / set of sentinel values.
 */
export function createDrawTileInterpolateColorCommand(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
  fragMacros: Dictionary<any>,
) {
  return regl<
    DrawTileInterpolateColor.Uniforms,
    DrawTileInterpolateColor.Attributes,
    DrawTileInterpolateColor.Props
  >({
    ...commonConfig,
    vert: vertDouble,
    frag: util.defineMacros(fragInterpolateColor, fragMacros),
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      scaleLengthA: regl.prop<DrawTileInterpolateColor.Props, 'scaleLengthA'>('scaleLengthA'),
      sentinelLengthA: regl.prop<DrawTileInterpolateColor.Props, 'sentinelLengthA'>('sentinelLengthA'),
      scaleColormapA: regl.prop<DrawTileInterpolateColor.Props, 'scaleColormapA'>('scaleColormapA'),
      sentinelColormapA: regl.prop<DrawTileInterpolateColor.Props, 'sentinelColormapA'>('sentinelColormapA'),
      scaleLengthB: regl.prop<DrawTileInterpolateColor.Props, 'scaleLengthB'>('scaleLengthB'),
      sentinelLengthB: regl.prop<DrawTileInterpolateColor.Props, 'sentinelLengthB'>('sentinelLengthB'),
      scaleColormapB: regl.prop<DrawTileInterpolateColor.Props, 'scaleColormapB'>('scaleColormapB'),
      sentinelColormapB: regl.prop<DrawTileInterpolateColor.Props, 'sentinelColormapB'>('sentinelColormapB'),
      textureA: (_, { textureA }) => textureA,
      textureB: (_, { textureB }) => textureB,
      interpolationFraction: (_, { interpolationFraction }) => interpolationFraction,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoordA: (_, { textureBoundsA }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsA),
      texCoordB: (_, { textureBoundsB }) => util.getTexCoordVerticesTriangleStripQuad(textureBoundsB),
    },
  });
}

/**
 * The behavior of this DrawCommand is similar to the one above, except that the pixel values
 * are the same. Only the colorscale changes.
 */
export function createDrawTileInterpolateColorOnlyCommand(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
  fragMacros: Dictionary<any>,
) {
  return regl<
    DrawTileInterpolateColorOnly.Uniforms,
    DrawTileInterpolateColorOnly.Attributes,
    DrawTileInterpolateColorOnly.Props
  >({
    ...commonConfig,
    vert: vertSingle,
    frag: util.defineMacros(fragInterpolateColorOnly, fragMacros),
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      scaleLengthA: regl.prop<DrawTileInterpolateColorOnly.Props, 'scaleLengthA'>('scaleLengthA'),
      sentinelLengthA: regl.prop<DrawTileInterpolateColorOnly.Props, 'sentinelLengthA'>('sentinelLengthA'),
      scaleColormapA: regl.prop<DrawTileInterpolateColorOnly.Props, 'scaleColormapA'>('scaleColormapA'),
      sentinelColormapA: regl.prop<DrawTileInterpolateColorOnly.Props, 'sentinelColormapA'>('sentinelColormapA'),
      scaleLengthB: regl.prop<DrawTileInterpolateColorOnly.Props, 'scaleLengthB'>('scaleLengthB'),
      sentinelLengthB: regl.prop<DrawTileInterpolateColorOnly.Props, 'sentinelLengthB'>('sentinelLengthB'),
      scaleColormapB: regl.prop<DrawTileInterpolateColorOnly.Props, 'scaleColormapB'>('scaleColormapB'),
      sentinelColormapB: regl.prop<DrawTileInterpolateColorOnly.Props, 'sentinelColormapB'>('sentinelColormapB'),
      texture: (_, { texture }) => texture,
      interpolationFraction: (_, { interpolationFraction }) => interpolationFraction,
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoord: (_, { textureBounds }) => util.getTexCoordVerticesTriangleStripQuad(textureBounds),
    },
  });
}

/**
 * The resulting Regl DrawCommand is for using a convolution kernel to smooth the input data.
 * Currently hard-coded the kernel and positions in the shader to reduce number of uniforms.
 */
export function createConvolutionSmoothCommand(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<ConvolutionSmooth.Uniforms, ConvolutionSmooth.Attributes, ConvolutionSmooth.Props>({
    vert: vertSingleNotTransformed,
    frag: fragConvolutionSmooth,
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      texture: regl.prop<ConvolutionSmooth.Props, 'texture'>("texture"),
      textureSize: regl.prop<ConvolutionSmooth.Props, 'textureSize'>("textureSize"),
      kernelSize: regl.prop<ConvolutionSmooth.Props, 'kernelSize'>("kernelSize"),
    },
    attributes: {
      texCoord: [0, 1, 1, 1, 0, 0, 1, 0],
      position: [-1, 1, 1, 1, -1, -1, 1, -1],
    },
    depth: { enable: false },
    primitive: 'triangle strip',
    count: 4,
  });
}

/**
 * The resulting Regl DrawCommand is used to get the float values from the 3x3
 * adjacent tiles. The float values can be scaled to adjust the hillshading.
 * It will be saved to a framebuffer and is used as an input to advanced hillshading
 */
export function createHsAdvMergeAndScaleTiles(
  regl: REGL.Regl,
) {
  return regl<HsAdvMergeAndScaleTiles.Uniforms, HsAdvMergeAndScaleTiles.Attributes, HsAdvMergeAndScaleTiles.Props>({
    vert: vertSingleNotTransformed,
    frag: fragHsAdvMergeAndScaleTiles,
    uniforms: {
      littleEndian: littleEndian,
      nodataValue: regl.prop<HsAdvMergeAndScaleTiles.Props, 'nodataValue'>("nodataValue"),
      texture: regl.prop<HsAdvMergeAndScaleTiles.Props, 'texture'>("texture"),
      floatScale: regl.prop<HsAdvMergeAndScaleTiles.Props, 'floatScale'>("floatScale"),
    },
    attributes: {
      // 18 triangles = 9 tiles
      position: [
        [-1, 1], [-1/3, 1], [-1, 1/3], [-1/3, 1/3], [-1/3, 1], [-1, 1/3],
        [-1, 1/3], [-1/3, 1/3], [-1, -1/3], [-1/3, -1/3], [-1/3, 1/3], [-1, -1/3],
        [-1, -1/3], [-1/3, -1/3], [-1, -1], [-1/3, -1], [-1/3, -1/3], [-1, -1],
        [-1/3, 1], [1/3, 1], [-1/3, 1/3], [1/3, 1/3], [1/3, 1], [-1/3, 1/3],
        [-1/3, 1/3], [1/3, 1/3], [-1/3, -1/3], [1/3, -1/3], [1/3, 1/3], [-1/3, -1/3],
        [-1/3, -1/3], [1/3, -1/3], [-1/3, -1], [1/3, -1], [1/3, -1/3], [-1/3, -1],
        [1/3, 1], [1, 1], [1/3, 1/3], [1, 1/3], [1, 1], [1/3, 1/3],
        [1/3, 1/3], [1, 1/3], [1/3, -1/3], [1, -1/3], [1, 1/3], [1/3, -1/3],
        [1/3, -1/3], [1, -1/3], [1/3, -1], [1, -1], [1, -1/3], [1/3, -1]
      ],
      texCoord: regl.prop<HsAdvMergeAndScaleTiles.Props, 'texCoord'>("texCoord"),
    },
    depth: { enable: false },
    primitive: 'triangles',
    count: 54,
    viewport: (_, { canvasSize: [width, height] }) => ({ width, height }),
    framebuffer: regl.prop<HsAdvMergeAndScaleTiles.Props, 'fbo'>("fbo"),
  });
}

/**
 * The resulting Regl DrawCommand is used to calculate the normals.
 * It is used as an input to advanced hillshading
 */
export function createHsAdvCalcNormals(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<HsAdvCalcNormals.Uniforms, HsAdvCalcNormals.Attributes, HsAdvCalcNormals.Props>({
    ...commonConfig,
    vert: vertSingleNotTransformed,
    frag: fragHsAdvNormals,
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      tInput: regl.prop<HsAdvCalcNormals.Props, 'tInput'>("tInput"),
      pixelScale: regl.prop<HsAdvCalcNormals.Props, 'pixelScale'>("pixelScale"),
      onePixel: regl.prop<HsAdvCalcNormals.Props, 'onePixel'>("onePixel"),
    },
    attributes: {
      position: [[-1, 1], [1, 1], [-1, -1], [1, -1]],
      texCoord: [[0, 1], [1, 1], [0, 0], [1, 0]],
    },
    framebuffer: regl.prop<HsAdvCalcNormals.Props, 'fbo'>("fbo"),
  });
}

/**
 * The resulting Regl DrawCommand is used to show hillshading without shadows.
 * Not currently used
 */
export function createHsAdvDirectLightning(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<HsAdvDirectLightning.Uniforms, HsAdvDirectLightning.Attributes, HsAdvDirectLightning.Props>({
    ...commonConfig,
    vert: vertSingleNotTransformed,
    frag: fragHsAdvDirectLight,
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      scaleLength: regl.prop<HsAdvDirectLightning.Props, 'scaleLength'>('scaleLength'),
      sentinelLength: regl.prop<HsAdvDirectLightning.Props, 'sentinelLength'>('sentinelLength'),
      scaleColormap: regl.prop<HsAdvDirectLightning.Props, 'scaleColormap'>('scaleColormap'),
      sentinelColormap: regl.prop<HsAdvDirectLightning.Props, 'sentinelColormap'>('sentinelColormap'),
      tInput: regl.prop<HsAdvDirectLightning.Props, 'tInput'>("tInput"),
      tNormal: regl.prop<HsAdvDirectLightning.Props, 'tNormal'>("tNormal"),
      floatScale: regl.prop<HsAdvDirectLightning.Props, 'floatScale'>("floatScale"),
      sunDirection: regl.prop<HsAdvDirectLightning.Props, 'sunDirection'>("sunDirection"),
    },
    attributes: {
      position: [[-1, 1], [1, 1], [-1, -1], [1, -1]],
      texCoord: [[0, 1], [1, 1], [0, 0], [1, 0]],
    },
  });
}

/**
 * The resulting Regl DrawCommand is used to calculate soft shadows.
 */
export function createHsAdvSoftShadows(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<HsAdvSoftShadows.Uniforms, HsAdvSoftShadows.Attributes, HsAdvSoftShadows.Props>({
    ...commonConfig,
    vert: vertSingleNotTransformed,
    frag: fragHsAdvSoftShadows,
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      tInput: regl.prop<HsAdvSoftShadows.Props, 'tInput'>("tInput"),
      tNormal: regl.prop<HsAdvSoftShadows.Props, 'tNormal'>("tNormal"),
      tSrc: regl.prop<HsAdvSoftShadows.Props, 'tSrc'>("tSrc"),
      softIterations: regl.prop<HsAdvSoftShadows.Props, 'softIterations'>("softIterations"),
      pixelScale: regl.prop<HsAdvSoftShadows.Props, 'pixelScale'>("pixelScale"),
      resolution: regl.prop<HsAdvSoftShadows.Props, 'resolution'>("resolution"),
      sunDirection: regl.prop<HsAdvSoftShadows.Props, 'sunDirection'>("sunDirection"),
    },
    attributes: {
      position: [[-1, 1], [1, 1], [-1, -1], [1, -1]],
      texCoord: [[1/3, 2/3], [2/3, 2/3], [1/3, 1/3], [2/3, 1/3]],
    },
    framebuffer: regl.prop<HsAdvSoftShadows.Props, 'fbo'>("fbo"),
  });
}

/**
 * The resulting Regl DrawCommand is used to calculate ambient lighting.
 */
export function createHsAdvAmbientShadows(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<HsAdvAmbientShadows.Uniforms, HsAdvAmbientShadows.Attributes, HsAdvAmbientShadows.Props>({
    ...commonConfig,
    vert: vertSingleNotTransformed,
    frag: fragHsAdvAmbientShadows,
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      tInput: regl.prop<HsAdvAmbientShadows.Props, 'tInput'>("tInput"),
      tNormal: regl.prop<HsAdvAmbientShadows.Props, 'tNormal'>("tNormal"),
      tSrc: regl.prop<HsAdvAmbientShadows.Props, 'tSrc'>("tSrc"),
      ambientIterations: regl.prop<HsAdvAmbientShadows.Props, 'ambientIterations'>("ambientIterations"),
      pixelScale: regl.prop<HsAdvAmbientShadows.Props, 'pixelScale'>("pixelScale"),
      resolution: regl.prop<HsAdvAmbientShadows.Props, 'resolution'>("resolution"),
      direction: regl.prop<HsAdvAmbientShadows.Props, 'direction'>("direction"),
    },
    attributes: {
      position: [[-1, 1], [1, 1], [-1, -1], [1, -1]],
      texCoord: [[1/3, 2/3], [2/3, 2/3], [1/3, 1/3], [2/3, 1/3]],
    },
    framebuffer: regl.prop<HsAdvAmbientShadows.Props, 'fbo'>("fbo"),
  });
}

/**
 * The resulting Regl DrawCommand is used to combine soft and ambient shading,
 * use the colormap on the input floats and apply the hillshading.
 */
export function createHsAdvFinalColorscale(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<HsAdvFinalColorscale.Uniforms, HsAdvFinalColorscale.Attributes, HsAdvFinalColorscale.Props>({
    ...commonConfig,
    vert: vertDouble,
    frag: fragHsAdvFinalColorscale,
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      scaleLength: regl.prop<HsAdvFinalColorscale.Props, 'scaleLength'>('scaleLength'),
      sentinelLength: regl.prop<HsAdvFinalColorscale.Props, 'sentinelLength'>('sentinelLength'),
      scaleColormap: regl.prop<HsAdvFinalColorscale.Props, 'scaleColormap'>('scaleColormap'),
      sentinelColormap: regl.prop<HsAdvFinalColorscale.Props, 'sentinelColormap'>('sentinelColormap'),
      tInput: regl.prop<HsAdvFinalColorscale.Props, 'tInput'>("tInput"),
      tSoftShadow: regl.prop<HsAdvFinalColorscale.Props, 'tSoftShadow'>("tSoftShadow"),
      tAmbient: regl.prop<HsAdvFinalColorscale.Props, 'tAmbient'>("tAmbient"),
      floatScale: regl.prop<HsAdvFinalColorscale.Props, 'floatScale'>("floatScale"),
      finalSoftMultiplier: regl.prop<HsAdvFinalColorscale.Props, 'finalSoftMultiplier'>("finalSoftMultiplier"),
      finalAmbientMultiplier: regl.prop<HsAdvFinalColorscale.Props, 'finalAmbientMultiplier'>("finalAmbientMultiplier"),
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoordA: [[1/3, 2/3], [2/3, 2/3], [1/3, 1/3], [2/3, 1/3]],
      texCoordB: [[0, 1], [1, 1], [0, 0], [1, 0]],
    },
  });
}

/**
 * The resulting Regl DrawCommand is used to combine soft and ambient shading,
 * use the baselayer tile and apply the hillshading.
 */
export function createHsAdvFinalBaselayer(
  regl: REGL.Regl,
  commonConfig: REGL.DrawConfig<DrawCommon.Uniforms, DrawCommon.Attributes, DrawCommon.Props>,
) {
  return regl<HsAdvFinalBaselayer.Uniforms, HsAdvFinalBaselayer.Attributes, HsAdvFinalBaselayer.Props>({
    ...commonConfig,
    vert: vertDouble,
    frag: fragHsAdvFinalBaselayer,
    uniforms: {
      ...commonConfig.uniforms as DrawCommon.Uniforms,
      tBase: regl.prop<HsAdvFinalBaselayer.Props, 'tBase'>("tBase"),
      tSoftShadow: regl.prop<HsAdvFinalBaselayer.Props, 'tSoftShadow'>("tSoftShadow"),
      tAmbient: regl.prop<HsAdvFinalBaselayer.Props, 'tAmbient'>("tAmbient"),
      finalSoftMultiplier: regl.prop<HsAdvFinalBaselayer.Props, 'finalSoftMultiplier'>("finalSoftMultiplier"),
      finalAmbientMultiplier: regl.prop<HsAdvFinalBaselayer.Props, 'finalAmbientMultiplier'>("finalAmbientMultiplier"),
    },
    attributes: {
      ...commonConfig.attributes as DrawCommon.Attributes,
      texCoordA: regl.prop<HsAdvFinalBaselayer.Props, 'baseTexCoords'>("baseTexCoords"),
      texCoordB: [[0, 1], [1, 1], [0, 0], [1, 0]],
    },
  });
}

